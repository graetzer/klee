<!DOCTYPE html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    .bar rect {
      fill: steelblue;
    }
    
    .bar text {
      fill: #fff;
      font: 10px sans-serif;
    }
    
    .node circle {
      fill: #999;
    }
    
    .node text {
      font: 7px sans-serif;
    }
    
    .node--internal circle {
      fill: #555;
    }
    
    .node--internal circle.nullptr {
      fill: #E82C0C;
    }
    
    .node--internal circle.outofbounds {
      fill: #E80C7A;
    }
    /*
    .node--internal text {
      text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
    }*/
    
    circle.simulatedNil {
      fill: #FF0DFF;
    }
    
    .link {
      fill: none;
      stroke: #555;
      stroke-opacity: 0.4;
      stroke-width: 1.5px;
    }
    
    .chart {
      display: block;
      margin: auto;
      margin-top: 40px;
    }
    
    text {
      font-size: 11px;
    }
    
    rect {
      fill: none;
    }
    
    .bar {
      fill: steelblue;
    }
    
    .bar:hover {
      fill: brown;
    }
    
    .axis--x path {
      display: none;
    }
  </style>
  <script src="/js/d3.min.js"></script>
  <script src="tree.js"></script>
  <script src="histogram.js"></script>
  <script src="arc.js"></script>
  <script src="chart.js"></script>
  <link rel="stylesheet" href="/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/default.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
</head>

<body>
  <h2>Memory Analysis</h2>
  <div id="statetree">
    <h4>State Tree</h4>
  </div>

  <div id="stack">
    <h4>Call Stack Overview</h4>
  </div>
  <div id="chart" style="float:leftâ€š"></div>
  <div id="mallocs" style="float:right">

  </div>
  <div style="clear:both">
  </div>

  <div id="histogram" style="clear:both">
    <h3>Histogram All Mallocs</h3>
  </div>
  <div id="treemap" style="position:relative">
    <h3>(disabled) TreeMap</h3>
  </div>

  <script>
    "use strict";
    var cache = {};

    function getFileLines(file, callback) {
      if (cache[file]) {
        callback(null, cache[file]);
        return;
      }
      d3.text("/src/" + file, function(error, text) {
        if (error) {
          callback(error);
          return;
        }
        var lines = text.match(/[^\r\n]+/g);
        cache[file] = lines;
        callback(null, lines);
      });
    }

    var margin = {
        top: 10,
        right: 30,
        bottom: 30,
        left: 30
      },
      width = 1000 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;

    d3.json("run.astats", function(error, events) {
      if (error) throw error;

      var mallocs = events.filter(el => el.malloc != undefined);
      showHistogram(mallocs.map(e => e.malloc), width, height, margin);

      var states = d3.values(d3.nest()
        .key(d => d.id)
        .rollup(function(leaves) {
          var errors = leaves.filter(e => e.error).map(e => {
            return {
              name: e.error,
              func: e.func,
              file: e.file.substring(e.file.lastIndexOf('/') + 1)
            }
          });

          var res = {
            id: leaves[0].id,
            parentId: leaves[0].id != 0 ? leaves[0].parentId : null,
            mallocs: leaves.filter(l => l.malloc != undefined),
            errors: errors
          }
          leaves.forEach(l => {
            if (l.terminated) {
              res.memory = l.memory
              res.simulatedNil = l.simulatedNil === true;
              res.file = l.file;
              res.line = l.line;
              if (l.stack) res.stack = l.stack;
            }
          });
          return res;
        }).map(events)).slice(0, -12);

      var root = d3.stratify()(states);
      showTree(root, width, height * 2, margin, function(mallocs, stack) {

        showChart("#chart", mallocs, width / 2, height, margin, function (m) {
          
        });

        if (!stack) return;
        // TODO switch between mallocs and stack for the code view
        stack.forEach(sf => {
          var file = sf.file.substring(sf.file.lastIndexOf('/') + 1);
          getFileLines(file, (error, lines) => {
            if (!lines || lines.length == 0) return;

            var min = Math.max(0, sf.line - 3);
            var max = Math.min(lines.length, sf.line + 3);
            var print = lines.slice(min, max);
            if (print.length == 0) return;

            var div = d3.select("#stack")
              .append("div")
              .attr("style", "border:solid 1px black")
              .append("strong")
              .text(sf.func);

            var code = div.append("pre")
              .append('code')
              .attr("class", "cpp")
              .text(function(d) {
                return print.join('\n');
              });

            //hljs.highlightBlock(code.node());
            //if (print) {render}

          });
        });
      });

      //var files = mallocs.map(m => {file:m.file, id:}).filter((f, pos, self) => self.indexOf(f) === pos);
      //var funcs = fileMallocs.map(m => m.func).filter((f, pos, self) => self.indexOf(f) === pos);



      /*
            function fileHirarchy(file) {
              var fileMallocs = mallocs.filter(m => m.file.lastIndexOf(file, 0) === 0);
              var funcs = fileMallocs.map(m => m.func).filter((f, pos, self) => self.indexOf(f) === pos);
              return funcs.map(f => ({
                name: f,
                children: fileMallocs.filter(m => m.func === f).map(m => ({
                  name: m.file.substring(m.file.lastIndexOf('/')+1) + " " + m.malloc+"b",
                  size: m.malloc
                }))
              }));
            }

            var files = mallocs.map(m => m.file.substring(0, m.file.lastIndexOf('#')))
                               .filter((f, pos, self) => self.indexOf(f) === pos) // O(n^2) method to get unique filenames
            root = {
              name: "Mallocs",
              children: files.map(file => ({ // functions
                name: file.substring(file.lastIndexOf('/') + 1, file.length),
                children: fileHirarchy(file)
              }))
            };
            showArc(d3.hierarchy(root), width, height * 2, margin);//;*/
    });
  </script>
</body>

</html>